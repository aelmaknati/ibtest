parasails.registerComponent("ajaxForm",{props:["syncing","cloudError","action","formErrors","formData","formRules","handleSubmitting","handleParsing"],data:function(){return{}},template:'\n  <form class="ajax-form" @submit.prevent="submit()" @keydown.meta.enter="keydownMetaEnter()">\n    <slot name="default"></slot>\n  </form>\n  ',beforeMount:function(){},mounted:async function(){if(void 0===this.action&&void 0===this.handleSubmitting)throw new Error("Neither `:action` nor `:handle-submitting` was passed in to <ajax-form>, but one or the other must be provided.");if(void 0!==this.action&&void 0!==this.handleSubmitting)throw new Error("Both `:action` AND `:handle-submitting` were passed in to <ajax-form>, but only one or the other should be provided.");if(!(void 0===this.action||_.isString(this.action)&&_.isFunction(Cloud[_.camelCase(this.action)])))throw new Error('Invalid `action` in <ajax-form>.  `action` should be the name of a method on the `Cloud` global.  For example: `action="login"` would make this form communicate using `Cloud.login()`, which corresponds to the "login" action on the server.');if(void 0!==this.action&&!_.isFunction(Cloud[this.action]))throw new Error('Unrecognized `action` in <ajax-form>.  Did you mean to type `action="'+_.camelCase(this.action)+'"`?  (<ajax-form> expects `action` to be provided in camelCase format.  In other words, to reference the action at "api/controllers/foo/bar/do-something", use `action="doSomething"`.)');if(void 0!==this.handleSubmitting&&!_.isFunction(this.handleSubmitting))throw new Error('Invalid `:handle-submitting` function passed to <ajax-form>.  (Any chance you forgot the ":" in front of the prop name?)  For example: `:handle-submitting="handleSubmittingSomeForm"`.  This function should be an `async function`, and it should either throw a special exit signal or return response data from the server.  (If this custom `handleSubmitting` will be doing something more complex than a single request to a server, feel free to return whatever amalgamation of data you wish.)');if(void 0===this.handleParsing&&void 0===this.formData)throw new Error("Neither `:form-data` nor `:handle-parsing` was passed in to <ajax-form>, but one or the other must be provided.");if(void 0!==this.handleParsing&&void 0!==this.formData)throw new Error("Both `:form-data` AND `:handle-parsing` were passed in to <ajax-form>, but only one or the other should be provided.");if(void 0!==this.handleParsing&&!_.isFunction(this.handleParsing))throw new Error('Invalid `:handle-parsing` function passed to <ajax-form>.  (Any chance you forgot the ":" in front of the prop name?)  For example: `:handle-parsing="handleParsingSomeForm"`.  This function should return a dictionary (plain JavaScript object like `{}`) of parsed form data, ready to be sent in a request to the server.');if(void 0!==this.formData&&(!_.isObject(this.formData)||_.isFunction(this.formData)||_.isArray(this.formData)))throw new Error('Invalid `:form-data` passed to <ajax-form>.  (Any chance you forgot the ":" in front of the prop name?)  For example: `:form-data="someFormData"`.  This should reference a dictionary (plain JavaScript object like `{}`).  Specifically, `:form-data` should only be used in the case where the raw data from the form in the user interface happens to correspond **EXACTLY** with the names and format of the argins that should be sent in a request to the server.  (For more nuanced behavior, use `handle-parsing` instead!)');if(!this.formData&&(this.formRules||this.formErrors))throw new Error('If `:form-rules` or `:form-errors.sync` are in use, then `:form-data` must also be passed in.  (If the AJAX request doesn\'t need form data, then use an empty dictionary, i.e. `:form-data="{}"`.)');if(this.formRules&&!this.formErrors)throw new Error("If `:form-rules` are provided, then `:form-errors.sync` must also be passed in.");if(this.formRules){var SUPPORTED_RULES=["required","isEmail","isIn","is","minLength","maxLength","sameAs","isHalfwayDecentPassword","custom"];for(let fieldName in this.formRules)for(let ruleName in this.formRules[fieldName])if(!_.contains(SUPPORTED_RULES,ruleName)){let kebabRules=_.map(_.clone(SUPPORTED_RULES),(ruleName=>_.kebabCase(ruleName))),lowerCaseRules=_.map(_.clone(SUPPORTED_RULES),(ruleName=>ruleName.toLowerCase())),ruleIdx=-1===_.indexOf(kebabRules,ruleName)?-1===_.indexOf(lowerCaseRules,ruleName.toLowerCase())?-1:_.indexOf(lowerCaseRules,ruleName.toLowerCase()):_.indexOf(kebabRules,ruleName);throw-1!==ruleIdx?new Error("Did you mean `"+SUPPORTED_RULES[ruleIdx]+"`?  (note the capitalization)\nYou are seeing this error because <ajax-form> encountered an unsupported (but vaguely familiar-looking) client-side validation rule: `"+ruleName+"`."):new Error("<ajax-form> does not support that client-side validation rule (`"+ruleName+"`).\n [?] If you're unsure, visit https://sailsjs.com/support")}}"undefined"!=typeof bowser&&!bowser.mobile&&this.$find("[focus-first]").length>0&&this.$focus("[focus-first]")},beforeDestroy:function(){},methods:{keydownMetaEnter:async function(){await this._submit()},submit:async function(){await this._submit()},_submit:async function(){if(!this.syncing){var argins,failedWithCloudExit,rawErrorFromCloudSDK,result;if(this.$emit("update:cloudError",""),this.handleParsing){if(void 0===(argins=this.handleParsing()))return;if(!_.isObject(argins)||_.isArray(argins)||_.isFunction(argins))throw new Error("Invalid data returned from custom form parsing logic.  (Should return a dictionary of argins, like `{}`.)")}else if(this.formData){argins=this.formData;let formData=this.formData,formErrors={};for(let fieldName in this.formRules){let fieldValue=formData[fieldName];for(let ruleName in this.formRules[fieldName]){let violation,ruleRhs=this.formRules[fieldName][ruleName],isFieldValuePresent=void 0!==fieldValue&&""!==fieldValue&&!_.isNull(fieldValue);if("required"!==ruleName||!0!==ruleRhs&&!1!==ruleRhs)if(isFieldValuePresent)if("isEmail"!==ruleName||!0!==ruleRhs&&!1!==ruleRhs)if("isIn"===ruleName&&_.isArray(ruleRhs))violation=!_.contains(ruleRhs,fieldValue);else if("is"===ruleName)violation=ruleRhs!==fieldValue;else if("minLength"===ruleName&&_.isNumber(ruleRhs))violation=!_.isString(fieldValue)||fieldValue.length<ruleRhs;else if("maxLength"===ruleName&&_.isNumber(ruleRhs))violation=!_.isString(fieldValue)||fieldValue.length>ruleRhs;else if("sameAs"===ruleName&&""!==ruleRhs&&_.isString(ruleRhs)){violation=formData[ruleRhs]!==fieldValue}else if("isHalfwayDecentPassword"!==ruleName||!0!==ruleRhs&&!1!==ruleRhs){if("custom"!==ruleName||!_.isFunction(ruleRhs))throw new Error("Cannot interpret client-side validation rule (`"+ruleName+"`) because the configuration provided for it is not recognized by <ajax-form>.\n [?] If you're unsure, visit https://sailsjs.com/support");try{violation=!ruleRhs(fieldValue)}catch(err){console.warn(err),violation=!0}}else violation=!1!==ruleRhs&&(!_.isString(fieldValue)&&!_.isNumber(fieldValue)||fieldValue.length<6);else violation=!1!==ruleRhs&&!parasails.util.isValidEmailAddress(fieldValue);else;else violation=!1!==ruleRhs&&!isFieldValuePresent;if(violation){formErrors[fieldName]=ruleName;break}}}if(this.$emit("update:formErrors",formErrors),Object.keys(formErrors).length>0)return void("production"!==this._environment&&console.warn(`<ajax-form> encountered ${Object.keys(formErrors).length} form error${1!==Object.keys(formErrors).length?"s":""} when performing client-side validation of "form-data" versus "form-rules".  (Note: This warning is only here to assist with debugging-- it will not be displayed in production.  If you're unsure, check out https://sailsjs.com/support for more resources.)`,_.cloneDeep(formErrors)))}if(this.$emit("update:syncing",!0),this.handleSubmitting)try{result=await this.handleSubmitting(argins)}catch(err){if(rawErrorFromCloudSDK=err,_.isString(err)&&""!==err)failedWithCloudExit=err;else if(_.isError(err)&&err.exit)failedWithCloudExit=err.exit;else{if(!_.isObject(err)||_.isError(err)||_.isArray(err)||_.isFunction(err)||!Object.keys(err)[0]||!_.isString(Object.keys(err)[0]))throw err;failedWithCloudExit=Object.keys(err)[0]}}else result=await Cloud[this.action].with(argins).tolerate((err=>{rawErrorFromCloudSDK=err,failedWithCloudExit=err.exit||"error"}));failedWithCloudExit&&this.$emit("update:cloudError",failedWithCloudExit),this.$emit("update:syncing",!1),failedWithCloudExit?this.$emit("rejected",rawErrorFromCloudSDK):this.$emit("submitted",result)}}}});